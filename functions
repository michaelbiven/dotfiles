#!/usr/bin/env bash

# drain gearman queue
# drain_gearman HOSTNAME FUNCTION NAME
function drain_gearman() {
  gearman -t 1000 -n -w -h $1-f $2 > /dev/null
}

# Create a new directory and enter it
function mkd() {
	mkdir -p "$@" && cd "$@"
}

# Print top commands
function wh() {
  history | awk '{print $2};' | sort | uniq -c | sort -rn | head -20
}

# Tired of expanding ls to find out I need to switch to less
function l () {
    if [[ -z $1 ]]; then
        ls
    elif [[ -d $1 ]]; then
        # echo "$1 is a directory"
        ls $1
    elif [[ "$(file -bL --mime $1)" == *"charset=binary"* ]]; then
        # echo "$1 is a binary"
        file $1
    elif [[ -f $1 ]]; then
        # echo "$1 is a file"
        less $1
        file $1
    else
        #echo "$1 is not valid#"
        file $1
    fi
}

# Determine size of a file or total size of a directory
function fs() {
	if du -b /dev/null > /dev/null 2>&1; then
		local arg=-sbh
	else
		local arg=-sh
	fi
	if [[ -n "$@" ]]; then
		du $arg -- "$@"
	else
		du $arg .[^.]* *
	fi
}

# View TLS
function ciphers() {
  nmap --script ssl-cert,ssl-enum-ciphers -p 443,993 "$@"
}

# Get the common name and all he SANS for a https
#
function getcertnames() {
  if [ -z "${1}" ]; then
    echo "ERROR: No domain specified."
    return 1
  fi

  local domain="${1}"
  echo "Testing ${domain}â€¦"
  echo ""; # newline

  local tmp=$(echo -e "GET / HTTP/1.0\nEOT" \
    | openssl s_client -connect "${domain}:443" 2>&1)

  if [[ "${tmp}" = *"-----BEGIN CERTIFICATE-----"* ]]; then
    local certText=$(echo "${tmp}" \
      | openssl x509 -text -certopt "no_header, no_serial, no_version, \
      no_signame, no_validity, no_issuer, no_pubkey, no_sigdump, no_aux")
    echo "Common Name:"
    echo ""; # newline
    echo "${certText}" | grep "Subject:" | sed -e "s/^.*CN=//"
    echo ""; # newline
    echo "Subject Alternative Name(s):"
    echo ""; # newline
    echo "${certText}" | grep -A 1 "Subject Alternative Name:" \
      | sed -e "2s/DNS://g" -e "s/ //g" | tr "," "\n" | tail -n +2
    return 0
  else
    echo "ERROR: Certificate not found."
    return 1
  fi
}

# print active network services
function nets() {
  networksetup -listallnetworkservices | grep -v "*" | xargs 
}

# networksetup -listallnetworkservices | grep -v "*" | tr '\n' '\0' | xargs  -0 -L1 -I  '$' sudo networksetup -setdnsservers "$" "$@"


#echo 'myString$Blah'
#cat x.list | tr '\n' '\0' | xargs -0 -L1 -I '$' echo 'myString$Blah'

# alias cloudflaredns='sudo networksetup -setdnsservers "Wi-Fi" 1.1.1.1 && sudo networksetup -setdnsservers "Thunderbolt Ethernet" 1.1.1.1'

# docker images -q -f dangling=true | xargs docker rmi

# print legend for prompt
function prompt() {
  cat << EOF
+ uncommitted changes
! unstaged changes
? untracked files
$ stashed files
EOF
}

# Credit: https://gist.github.com/dansimau/f5d8b0b2aefb9c9c46621f4869ccc151
#
# Change to the directory of the specified Go package name.
#
gg() {
	paths=($(g "$@"))
	path_index=0

	if [ ${#paths[@]} -gt 1 ]; then
		c=1
		for path in "${paths[@]}"; do
			echo [$c]: cd ${GOPATH}/${path}
			c=$((c+1))
		done
		echo -n "Go to which path: "
		read path_index

		path_index=$(($path_index-1))
	fi

	path=${paths[$path_index]}
	cd $GOPATH/src/$path
}

#
# Print the directories of the specified Go package name.
#
g() {
	local pkg_candidates="$((cd $GOPATH/src && find . -mindepth 1 -maxdepth 5 -type d \( -path "*/$1" -or -path "*/$1.git" \) -print) | sed 's/^\.\///g')"
	echo "$pkg_candidates"
}

#
# Bash autocomplete for g and gg functions.
#
_g_complete()
{
    COMPREPLY=()

    local cur
    local prev

    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"

    COMPREPLY=( $(compgen -W "$(for f in $(find "$GOPATH/src" -mindepth 1 -maxdepth 5 -type d -name "${cur}*" ! -name '.*' ! -path '*/.git/*' ! -path '*/test/*' ! -path '*/Godeps/*' ! -path '*/examples/*'); do echo "${f##*/}"; done)" --  "$cur") )
    return 0
}

complete -F _g_complete g
complete -F _g_complete gg
